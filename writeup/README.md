# Авторский writeup на сервис SX

## Введение

Сервис SX (South X) - это упрощенный аналог социальной сети X (ранее twitter).

Посты (tweet'ы) могут быть как публичными, так и приватными.
Прочитать публичные посты, можно через `GET /posts/user/{user_id}`
или подписавшись на интересующих пользователей и получив свой feed через
`GET /feed/others`.

Приватные посты видны только автору и тем пользователям, на которых он подписан.

Чекер создает пользователя #1,
складывает флаг в приватный пост и подписывается на пользователя #2.
При проверке, пользователь #2 проверяет, что ему доступен флаг
в приватном посте пользователя #1".

## Уязвимости

### Доступ к защищенному методу

При обращении к `GET /feed/{feed_type}` можно получить посты. В зависимости от
`{feed_type}`, будут выданы посты:
- my - посты текущего пользователя
- others - посты пользователей, на которых он подписан

Но в `app.managers.post.PostManager` есть также и защищенный метод `__get_all`,
который не фильтрует посты и через него можно получить флаги.
Но просто передать `__get_all` недостаточно, так как напрямую обратиться к
защищенному методу нельзя.
Однако можно передать `_PostManager__get_all` и тогда можно получить последние 100
постов, в которых будут актуальные флаги.

#### Эксплоит

Создаем пользователя, авторизовываемся и получаем Bearer токен.

Далее

```bash
curl -X 'GET' \
  'http://localhost:3080/feed/_PostManager__get_all' \
  -H 'accept: application/json' \
  -H 'Authorization: Bearer e481f6af-8d94-466f-9503-dab1f8c9aa3f'
```

### Nginx alias path traversal

Nginx помимо того, что пробрасывает api, также дает скачивать аватарки.
Но благодаря неправильной конфигурации можно скачать sqlite базу сервиса.

#### Эксплойт

```bash
curl -X "GET" "http://localhost:3080/avatars../database" --output -
```

### Неправильная проверка пароля пользователя

```python
async def check_password(actual_passw: str, expected_passw: str, ms: int = 30) -> bool:
    if len(actual_passw) != len(expected_passw):
        return False
    for actual_symbol, expected_symbol in zip(actual_passw, expected_passw):
        if actual_symbol != expected_symbol:
            return False
        await asyncio.sleep(ms * 1e-3)
    return True
```

Тут если пароли одинаковы по длине, то идет сравнение посимвольно.
Чем больше символов будут правильны, тем дольше будет проверка.
(Каждый успешный символ - 30 мс)

Sleep маленький и возможно в игровой сетке он будет незаметен.
Но если запросы будут идти стабильно, то начинаем посимвольно переберать,
самый долгий запрос - это и есть правильный символ.

Все упрощается тем, что в качестве пароля выбирается uuid подобная строка,
перебор существенно сужается.

#### Фикс
Сравниваемые строки хэшируем и сравниваем без всяких слипов.
